import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import pandas as pd

# import matplotlib
# matplotlib.use('Qt5Agg')

EPSILON = 0.01
MAX_ITER = 10000
_ = np.seterr('ignore')


def plot_function():
    """
    Plot the function:

    .. math:: f(x_1, x_2) = (-2x_1^2 -3x_1x_2 + 2x_2^2)sin(x_1)
    """
    x1 = np.linspace(-6, 6, 50)
    x2 = np.linspace(-6, 6, 50)
    X1, X2 = np.meshgrid(x1, x2)
    Y = f(X1, X2)
    ax = plt.axes(projection='3d')
    ax.plot_surface(X1, X2, Y, rstride=1, cstride=1, cmap='viridis', edgecolor='none')
    ax.set_xlabel('x1')
    ax.set_ylabel('x2')
    ax.set_zlabel('y')
    plt.show()


def gradient_descent(x1_0, x2_0, max_iter, rho):
    """
    This function runs gradient descent.
    :param x1_0: initial x1
    :param x2_0: initial x2
    :param max_iter: max number of iteration
    :param rho: learning rate
    :return:
    """
    point_list = [np.array([x1_0, x2_0, f(x1_0, x2_0)])]
    curr_point = np.array([x1_0, x2_0, 0])
    for i in range(0, max_iter):
        curr_point, new_dir = single_descent(curr_point, rho)
        if np.linalg.norm(new_dir) < EPSILON:
            print("The total number of iterations is: {}".format(i + 1))
            return point_list
        elif np.abs(curr_point[0]) > 6 or np.abs(curr_point[1]) > 6:
            print("Out of range! (x1, x2) = ({}, {}), iteration number: {}".format(curr_point[0], curr_point[1], i + 1))
            return point_list
        elif np.any(np.isinf(curr_point)):
            print("It reaches infinite, does not converge!\n"
                  "The total number of iterations is: {}".format(i + 1))
            return point_list
        point_list += [curr_point]
    print("Exceeds max iteration: {}; with learning rate: {}".format(max_iter, rho))
    return point_list


def single_descent(point, rho):
    x1 = point[0]
    x2 = point[1]
    dx1 = np.sin(x1) * (-4. * x1 - 3. * x2) + np.cos(x1) * (-2. * np.power(x1, 2) - 3. * x1 * x2 + 2. * np.power(x2, 2))
    dx2 = np.sin(x1) * (4. * x2 - 3. * x1)
    new_x1 = x1 - dx1 * rho
    new_x2 = x2 - dx2 * rho
    new_y = f(new_x1, new_x2)
    return np.array([new_x1, new_x2, new_y]), np.array([dx1, dx2])


def f(x1, x2):
    return np.sin(x1) * (-2. * np.power(x1, 2) - 3. * x1 * x2 + 2. * np.power(x2, 2))


def plot_learning_points(points):
    """
    Plot the points sequence generated by gradient descent
    :param points: Input points generated from gradient descent
    """
    df = pd.DataFrame(points, columns=['x1', 'x2', 'y'])
    df = df.replace([np.inf, -np.inf], np.nan).dropna()
    xs = df['x1'].values.tolist()
    ys = df['x2'].values.tolist()
    zs = df['y'].values.tolist()
    ax = plt.axes(projection='3d')
    ax.scatter3D(xs, ys, zs, c=zs)
    ax.plot3D(xs, ys, zs, 'gray')
    ax.set_xlabel('x_1')
    ax.set_ylabel('x_2')
    ax.set_zlabel('y')
    plt.show()


def main():
    plot_function()

    point_result1 = gradient_descent(-3, -4, MAX_ITER, 0.001)
    plot_learning_points(point_result1)
    # print(point_result1)  # [len(point_result1) - 5: len(point_result1)])

    point_result2 = gradient_descent(4, -3, MAX_ITER, 0.001)
    plot_learning_points(point_result2)
    # print(point_result2)  # print(point_result2[len(point_result2) - 5: len(point_result2)])

    point_result3 = gradient_descent(1, 5, MAX_ITER, 0.001)
    plot_learning_points(point_result3)
    # print(point_result3[len(point_result3) - 5: len(point_result3)])

    point_result4 = gradient_descent(-4, -3, MAX_ITER, 0.001)
    plot_learning_points(point_result4)
    # print(point_result4[len(point_result4) - 5: len(point_result4)])

    point_result5 = gradient_descent(-5, 5, MAX_ITER, 0.001)
    plot_learning_points(point_result5)
    # print(point_result5[len(point_result5) - 5: len(point_result5)])

    data = {
        '(-3,-4)': pd.DataFrame(point_result1[len(point_result1) - 5: len(point_result1)], columns=['x1', 'x2', 'y']),
        '(4,-3)': pd.DataFrame(point_result2[len(point_result2) - 5: len(point_result2)], columns=['x1', 'x2', 'y']),
        '(1,5)': pd.DataFrame(point_result3[len(point_result3) - 5: len(point_result3)], columns=['x1', 'x2', 'y']),
        '(-4,-3)': pd.DataFrame(point_result4[len(point_result4) - 5: len(point_result4)], columns=['x1', 'x2', 'y']),
        '(-5,5)': pd.DataFrame(point_result5[len(point_result5) - 5: len(point_result5)], columns=['x1', 'x2', 'y'])}
    # print("dataframe")
    # print(data['(-3,-4)'])
    min_points = pd.DataFrame()
    for key in data:
        min_index = data[key]['y'].idxmin()
        print(data[key])
        min_points = pd.concat([min_points, data[key].loc[min_index].to_frame().transpose()])
    min_points.reset_index(drop=True, inplace=True)
    min_index = min_points['y'].idxmin()
    best_min_value = min_points.loc[min_index]
    print(best_min_value["y"])


if __name__ == "__main__":
    main()
